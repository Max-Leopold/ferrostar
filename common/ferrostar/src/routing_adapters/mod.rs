use crate::models::Waypoint;
use crate::{
    create_osrm_response_parser, create_valhalla_request_generator,
    models::{Route, UserLocation},
};
use error::{RoutingRequestGenerationError, RoutingResponseParseError};
use std::collections::HashMap;
use std::fmt::Debug;
use std::sync::Arc;

pub mod error;
pub mod osrm;
pub mod valhalla;

/// A route request generated by a [RouteRequestGenerator].
#[derive(PartialEq, Debug, uniffi::Enum)]
pub enum RouteRequest {
    HttpPost {
        url: String,
        headers: HashMap<String, String>,
        body: Vec<u8>,
    },
}

/// A trait describing any object capable of generating [RouteRequest]s.
///
/// The interface is intentionally generic. Every routing backend has its own set of
/// parameters, including a "profile," max travel speed, units of speed and distance, and more.
/// It is assumed that these properties will be set at construction time or otherwise configured
/// before use, so that we can keep the public interface as generic as possible.
///
/// Implementations may be either in Rust (most popular engines should eventually have Rust
/// glue code) or foreign code.
#[uniffi::export(with_foreign)]
pub trait RouteRequestGenerator: Send + Sync {
    /// Generates a routing backend request given the set of locations.
    ///
    /// While most implementations will treat the locations as an ordered sequence, this is not
    /// guaranteed (ex: an optimized router).
    // TODO: Arbitrary options; how can we make this generic???
    // TODO: Option for whether we should account for course over ground or heading.
    fn generate_request(
        &self,
        user_location: UserLocation,
        waypoints: Vec<Waypoint>,
    ) -> Result<RouteRequest, RoutingRequestGenerationError>;

    // TODO: "Trace attributes" request method? Maybe in a separate trait?
}

/// A generic interface describing any object capable of parsing a response from a routing
/// backend into one or more [Route]s.
#[uniffi::export(with_foreign)]
pub trait RouteResponseParser: Send + Sync {
    /// Parses a raw response from the routing backend into a route.
    ///
    /// We use a sequence of octets as a common interchange format.
    /// as this works for all currently conceivable formats (JSON, PBF, etc.).
    fn parse_response(&self, response: Vec<u8>) -> Result<Vec<Route>, RoutingResponseParseError>;
}

/// The route adapter bridges between the common core and a routing backend where interaction takes place
/// over a generic request/response flow (typically over a network;
/// local/offline routers **do not use this object** as the interaction patterns are different).
///
/// This is essentially the composite of the [RouteRequestGenerator] and [RouteResponseParser]
/// traits, but it provides one further level of abstraction which is helpful to consumers.
/// As there is no way to signal compatibility between request generators and response parsers,
/// the [RouteAdapter] provides convenience constructors which take the guesswork out of it,
/// while still leaving consumers free to implement one or both halves.
///
/// In the future, we may provide additional methods or conveniences, and this
/// indirection leaves the design open to such changes without necessarily breaking source
/// compatibility.
/// One such possible extension would be the ability to fetch more detailed attributes in real time.
/// This is supported by the Valhalla stack, among others.
///
/// Ideas  welcome re: how to signal compatibility between request generators and response parsers.
/// I don't think we can do this in the type system, since one of the reasons for the split design
/// is modularity, including the possibility of user-provided implementations, and these will not
/// always be of a "known" type to the Rust side.
#[derive(uniffi::Object)]
pub struct RouteAdapter {
    request_generator: Arc<dyn RouteRequestGenerator>,
    response_parser: Arc<dyn RouteResponseParser>,
}

#[uniffi::export]
impl RouteAdapter {
    #[uniffi::constructor]
    pub fn new(
        request_generator: Arc<dyn RouteRequestGenerator>,
        response_parser: Arc<dyn RouteResponseParser>,
    ) -> Self {
        Self {
            request_generator,
            response_parser,
        }
    }

    #[uniffi::constructor]
    pub fn new_valhalla_http(
        endpoint_url: String,
        profile: String,
        costing_options: HashMap<String, HashMap<String, String>>,
    ) -> Self {
        let request_generator =
            create_valhalla_request_generator(endpoint_url, profile, costing_options);
        let response_parser = create_osrm_response_parser(6);
        Self::new(request_generator, response_parser)
    }

    //
    // Proxied implementation methods.
    //

    pub fn generate_request(
        &self,
        user_location: UserLocation,
        waypoints: Vec<Waypoint>,
    ) -> Result<RouteRequest, RoutingRequestGenerationError> {
        self.request_generator
            .generate_request(user_location, waypoints)
    }

    pub fn parse_response(
        &self,
        response: Vec<u8>,
    ) -> Result<Vec<Route>, RoutingResponseParseError> {
        self.response_parser.parse_response(response)
    }
}
